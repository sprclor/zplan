作用域作为实体的元描述而存在，它本身也具有描述信息。根据它不同的描述信息可以分为函数作用域和块级作用域。

#### 函数作用域

###### 绑定函数
```
fn ( n num ) num {
    if n == 1 {
        return 1
    } else {
        return n + &( n - 1 )
    }
}
```
以上示例中确定了一个函数与其新作用域的绑定关系，使得这个新作用域携带`绑定函数`这个特殊信息。
使用`&`来获得这个绑定函数的引用。

###### me
```
fn greet( ) {
    print("Hello, " + me.name )
}
```
函数作用域还携带了`me`这个信息，它是一个Any类型的形式变量，这意味着需要在使用它才指定具体值。
```
greet() // Error: Unspecified value of [me].
{ name: "Zkip" }.greet() // Hello, Zkip
```
当在函数定义中使用`me`时，同时也在限制`me`的使用条件。
```
{ age: 23 }.greet() // Error: [me] doesn't have a [name] filed.
{ name: 23 }.greet() // Error: [me]'s [name] filed type doesn't match ( must str but given num ).
```

另外`me`可以被显式地定义，通过这种方式`me`就不再具有动态的特征了。
```
type People {
    name str
}

type Pet {
    name str
}

type Student like People {
    score num
}

fn People.greet( ) {
    print("Hello, " + me.name )
}

let zkiplan = People{ "Zkip" }
let myPet = Pet{ "whatever" }
let lpei = Student{ "L.pei" }
zkiplan.greet() // Hello, Zkip
myPet.greet()   // Error: This type doesn't have a [greet] method.
lpei.greet()    // Hello, L.pei.
```

#### 块级作用域
```
{
    ...
}
```
这种作用域没有携带任何可以引用的描述信息。