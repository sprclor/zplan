函数实体具体化之后产生`任务`。

在系统运行时，调用函数实际上是在具体化函数实体，相应的任务则会产生。

这是任务的结构：

```
type Task {
	
}
```

###### 任务的执行方式

默认的执行方式是串行。下一个指令需要等到当前任务完成时系统才会继续往前推进时机。

串行不需要访问它的任务，它直接返回结果。

```
a()
b()
```



另一种方式是并行。可以将任务转移至新的时机，使新任务不阻塞当前时机的推进。

```
fn resolve( ) { ... }

go resolve( )
await go resolve( )
resolve( )

task[100] group
for 100 {
	group.push(go resolve( ))
}
await group
```

使用go将任务转移至新时机并返回这个任务，await可以一直等待直到任务完成并且返回任务的结果。

可以使用task查看它的时机。

```
fn download( ) {
	let header = await getHeader( ... )
	task.total = header.size
	for {
		let { block } = await getBlock( ... )
		task.current = block.num
	}
	...
}

let r_task = go download( )
for {
	sleep( 1s )
	print( "Completion Percent: ", r_task.total / r_task.current )
}
```

