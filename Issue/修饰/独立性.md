用于形容目标独立性的修饰有：

+ 独立的（Independent）
+ 依赖的（Dependent）
+ 非素依赖的（Non Pure-Solid-Dependent）

目标依赖其它目标的数量是它们的`依赖量`，越大表示越具有依赖性。

独立的表示目标的依赖量不能超过0，依赖的则表示可以超过0，所以依赖的真包含独立的，它们并不是互斥的。另外



函数默认为是依赖的，可以用`独立的`进行修饰。

`独立的`可以显式的修饰函数，被修饰的函数被成为`独立函数`，独立函数的作用域被称为`独立作用域`。



另外一种只依赖除了素体以外的其它实体的特殊依赖作用域被称为`非素依赖域`。

非素依赖域具有如下性质：

+ 无法更改和读取子域中的素体
+ 无法调用依赖函数

```
fn some() {}

fn-npsd double(v) {
	return v * 2
}

fn-npsd do() {
	let b = double()
	a = 3 // Error:
	let b = a * 2 // Error:
	some() // Error:
	w := Writer()
	w.write()
	h := Human() // Error:
	
	return a
}

fn* do() { ... } // 简便的表达
let a = *() => { ... }
a := *v => v

jackie := "Jackie"

type Human {
	name str
	( ) {
		name = jackie
	}
}

type Writer like Human {
	*( name str ) {
		People{ name }
	}
	- *check() { ... }
	*write() { ... }
	npsd submit() { ... }
}

p := People()
```



包默认是依赖的，使用独立的进行修饰可使包无法引用其它的包。

```
package-idpt main

use net // Error:
```



与函数相反，素体默认是独立的，同样可以用`依赖的`来显式地修饰：

```
let a = 10
dpt d = 2 * a
float-dpt b = 3 * d
dpt e {
	if random() > 0.5 {
		return d
	} else {
		return 3 * b
	}
}
dpt j {
	
}
```

另外可以使用简便的表达方式：

```
$ d = 2 * a
$ float b = 3 * d
$ e { ... }
f := ${ ...}
```

这种素体被称为`依赖素体`，依赖素体包含额外的独立作用域，在该作用域中声明

要注意的是



依赖素体的执行性能和更新策略

